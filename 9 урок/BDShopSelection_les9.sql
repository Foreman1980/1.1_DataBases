/*---------------------------Отработка запросов по материалам урока № 9---------------------------*/

/*--------------------------Тема - Транзакции, переменные, представления--------------------------*/
-- Содержание:
-- Модуль № 1 - Транзакции
-- Модуль № 2 - Внутренняя реализация транзакций
-- Модуль № 3 - Переменные, временные таблицы и динамические запросы
-- Модуль № 4 - Представления

/*------------------------------------Модуль № 1 - Транзакции------------------------------------*/
-- План занятия:
-- Транзакции
-- Ключевые слова COMMIT и ROLLBACK
-- Точки сохранения
-- Режим автозавершения транзакций
-- Принцип ACID
-- Уровни изоляции

USE shop;

SELECT id, user_id, total
FROM accounts;

START TRANSACTION;
SELECT total FROM accounts WHERE user_id = 4;

UPDATE accounts
SET total = total - 2000.00
WHERE user_id = 4;

UPDATE accounts
SET total = total + 2000.00
WHERE user_id IS NULL;

-- проверил через терминал, пока таблица accounts не изменилась

COMMIT;

-- магия..., теперь изменилась

-- мы так же можем отменять транзакцию

START TRANSACTION;
SELECT total FROM accounts WHERE user_id = 4;

UPDATE accounts
SET total = total - 2000.00
WHERE user_id = 4;

UPDATE accounts
SET total = total + 2000.00
WHERE user_id IS NULL;

ROLLBACK;

-- проверил через терминал, таблица accounts не изменилась

-- Необратимые команды
-- CREATE INDEX
-- DROP INDEX
-- CREATE TABLE
-- DROP TABLE
-- truncate TABLE
-- ALTER TABLE
-- RENAME TABLE
-- CREATE DATABASE
-- DROP DATABASE
-- ALTER DATABASE

-- следует избегать помещать их в транзакции с другими операторами

Неявное завершение транзакций
-- CREATE INDEX
-- DROP INDEX
-- CREATE TABLE
-- DROP TABLE
-- truncate TABLE
-- ALTER TABLE
-- RENAME TABLE
-- CREATE DATABASE
-- DROP DATABASE
-- BEGIN
-- LOAD master DATA
-- LOCK TABLES
-- RENAME
-- SET autocommit=1
-- START TRANSACTION

START TRANSACTION;
SELECT total FROM accounts WHERE user_id = 4;

SAVEPOINT accounts_4;

UPDATE accounts
SET total = total - 2000.00
WHERE user_id = 4;

ROLLBACK TO SAVEPOINT accounts_4;

-- MySQL по-умолчанию работает в режиме автозавершения транзакций, в этом случае любая последовательность команд
-- будет восприниматься как транзакция

SET autocommit=0;

SELECT total FROM accounts WHERE user_id = 4;

UPDATE accounts
SET total = total - 2000.00
WHERE user_id = 4;

UPDATE accounts
SET total = total + 2000.00
WHERE user_id IS NULL;

SELECT id, user_id, total
FROM accounts;

-- чтобы сохранить изменения требуется ввести команду "COMMIT"

ROLLBACK;

SET autocommit=1;

-- Транзакции должны удовлетворять принципам ACID
-- Atomicy - атомарность
-- Consistency - согласованность
-- Isolation - изолированность
-- Durability - сохраняемость

-- Уровни изоляции (от слабого к более сильному уровню изоляции):
-- READ UNCOMMITTED
-- READ COMITTED
-- REPEATABLE READ - в MySQL по-умолчанию
-- SERIALIZABLE

-- Изменить уровень изоляции можно с помощью команды
-- SET TRANSACTION ISOLATION LEVEL READ COMMITTED;

/*-------------------------Модуль № 2 - Внутренняя реализация транзакций-------------------------*/
-- План занятия:
-- Взаимоблокировка
-- Журнал транзакций
-- Управление режимом сохранения транзакций
-- MVCC
-- Связь MVCC с уровнями изоляции

-- запрос параметров Журнала транзакций
SHOW variables LIKE 'innodb_log_%';
-- Журнал транзакций имеет два файла, размером по 50 Мб

-- Файлы Журнала транзакций находятся в каталоге данных
-- Получить путь к вашему каталогу данных можно с пом. след. запроса:
SHOW variables LIKE 'datadir';

-- InnoDB хранит таблицы всех баз данных в едином табличном пространстве, в файле "ibdata1"
-- Физически единое табличное пространство может располагаться в неск. файлах, более того, мы можем выделить отдельное
-- табличное пространство под каждую из таблиц

-- Транзакции помещаются в файлы Журнала транзакций "ib_logfile0" и "ib_logfile1" и потом перегоняются в "ibdata1"

-- Управление режимом сохранения журнала транзакций (за этот режим отвечает серверная переменная "innodb_flush_log_at_trx_commit"):
-- 0 - сохранение журнала раз в секунду
-- 1 - сохранение после каждой транзакции
-- 2 - сохранение журнала раз в секунду и после каждой транзакции
SHOW variables LIKE 'innodb_flush_log_at_trx_commit';

-- Давайте установим режим сохранения журнала транзакций на "раз в секунду":
SET GLOBAL innodb_flush_log_at_trx_commit = 0;
SHOW variables LIKE 'innodb_flush_log_at_trx_commit';

-- MVCC - многоверсионное управление конкурентным доступом
-- MVCC работает только на 2 и 3 уровнях изоляции ("READ COMITTED" и "REPEATABLE READ")

/*---------------Модуль № 3 - Переменные, временные таблицы и динамические запросы---------------*/
-- План занятия:
-- Пользовательские переменные
-- Системные переменные
-- Временные таблицы
-- Динамические запросы

-- Часто результаты запросов необходимо использовать я в последующих запросах, для этого полученные данные следует
-- сохранить во временных структурах. Эту задачу решают переменные SQL
-- объявление переменной начинается с символа алев "@", за которым следует имя переменной
SELECT @total := count(*) FROM products;
-- переменная будет доступна только в текущей сессии
SELECT @total;

/*-------------------------Извлечь товарную позицию с самой высокой ценой-------------------------*/
SELECT @max_price := max(price) FROM products;
SELECT name
FROM products
WHERE price = @max_price;

-- Если переменной присваивается значение столбца содержащего множество значений, переменной присвоится последнее
-- значение
SELECT @id := id FROM products;
SELECT @id;

-- Имена переменных не чувствительны к регистру
SELECT @id := 5, @ID := 3;
SELECT @id, @ID;

-- переменные также могу объявляться при помощи команды "SET". Команда "SET", в отличии от "SELECT" не возвращает
-- результирующую таблицу
SET @last := now() - INTERVAL 7 DAY;
SELECT curdate(), @last;

-- Чтобы получить полный список системных переменных, можно воспользоваться оператором "SHOW VARIABLES"
SHOW VARIABLES\G; -- с "\G" работает только в консоли
SHOW VARIABLES;

-- чтобы отфильтровать большое количество переменных можно использовать ключевое слово "LIKE"
SHOW VARIABLES LIKE 'read_buffer_size';

-- Сервер MySQL поддерживает два типа системных переменных:
-- GLOBAL - глобальные - влияют на весь сервер
-- SESSION - сеансовые - влияют на текущее соединение клиента с сервером

-- При старте сервера происходит инициализация глобальных переменных значениями по-умолчанию, оператор "SET" позволяет
-- изменять значение глобальных переменных уже после старта

-- Для этого перед именем переменной устанавливается ключевое слово "GLOBAL"
SET GLOBAL read_buffer_size = 2097152;

-- Вместо ключевого слова "GLOBAL" можно перед названием переменной указывать два символа @@
SET @@read_buffer_size = 2097152;

-- Кроме глобальных переменных сервер MySQL поддерживает набор сеансовых переменных для каждого соединения клиента
-- с сервером

-- При установке соединения с сервером, сеансовые переменные получают значения заданные для глобальных переменных,
-- однако Клиент, при помощи оператора "SET" может выставлять новые значения
SET SESSION read_buffer_size = 2097152;
-- действие такой переменной будет отражаться только на текущее соединение, не затрагивая соседних клиентов
-- существует альтернативная форма задания сессионных переменных
SET @@session.read_buffer_size = 2097152;

-- чтобы установить локальной переменной значение глобальной, достаточно присвоить локальной переменной ключевое слово
-- "DEFAULT"
SET read_buffer_size = DEFAULT;

-- Временная таблица автоматически удаляется при завершении соединения с сервером, а её имя действительно только в
-- течении данного соединения
-- CREATE TEMPORARY TABLE temp (id int, name varchar(255));
-- 
-- SHOW tables;
-- 
-- DESCRIBE temp;
-- 
-- Временные таблицы храняться в специальном табличном пространстве "ibtmp1"

-- Динамические запросы, это запросы, которые пользователи могут сохранять подобно переменным под конкретным именем и
-- вызывать позже в течении сессии
-- Для объявления динамического запроса используется команда "PREPARE"
PREPARE ver FROM 'SELECT VERSION()';

-- Выполняется такой динамический запрос при помощи команды "EXECUTE"
EXECUTE ver;

-- Если необходимо, чтобы динамический запрос существовал более длительное время, необходимо прибегнуть к
-- представлениям

-- Динамический запрос можно параметризовать
PREPARE prd FROM '  SELECT id, name, price
                    FROM products
                    WHERE catalog_id = ?'

SET @catalog_id := 1;

EXECUTE prd USING @catalog_id;

-- Динамический запрос может иметь более одного параметра, в таком случае они перечисляются через запятую, в том
-- порядке, в котором они встречаются в динамическом запросе
-- Динамический запрос всегда представляет собой лишь один запрос (вложенные динамич. запросы не допускаются)

-- Удалить динамический запрос можно при помощи оператора "DROP PREPARE"
DROP PREPARE prd;

/*-----------------------------------Модуль № 4 - Представления-----------------------------------*/
-- План занятия:
-- Создание представлений
-- Вертикальные и горизонтальные представления
-- Вставка записей в представление
-- Обновление представлений
-- Управление представлениями

-- Представление это запрос на выборку, которому присваивается уникальное имя и которые можно сохранять и удалять из БД
-- как обычную таблицу. Представления позволяют увидеть результат запроса таким образом, как будто это полноценная
-- таблица БД. Они позволяют более гибко управлять правами доступа к таблицам, также можно запретить прямое обращение
-- пользователей к таблицам и разрешить их только к представлениям

/*Создадим представление для таблицы "catalogs", в кот. записи будут поддерживаться в отсортированном состоянии*/

SELECT *
FROM catalogs;

-- Для создания представления используется программа "CREATE VIEW"
CREATE VIEW cat AS SELECT * FROM catalogs ORDER BY name; 

-- К представлению мы можем обращаться как к обычной таблице

SELECT * FROM cat;

-- Представления рассматриваются MySQL как полноценная таблица
SHOW TABLES;

CREATE VIEW cat_reverse(`catalog`, catalog_id) AS
SELECT name, id FROM catalogs;

SELECT *
FROM cat_reverse;

CREATE OR REPLACE VIEW namecat (id, name, total) AS
SELECT id, name, LENGTH(name) FROM catalogs;

SELECT *
FROM namecat
ORDER BY total DESC;

-- Алгоритм формирования конечного запроса
-- MERGE        -   запрос объединяется с представлением таким образом, что представление заменяет собой
--                  соответствующие части в запросе
-- TEMPTABLE    -   результирующая таблица представления помещается во временную таблицу, кот. затем используется в
--                  конечном запросе
-- UNDEFINED    -   СУБД MySQL самостоятельно пытается выбрать алгоритм, предпочитая использовать подход "MERGE" и
--                  прибегая к алгоритму "TEMPTABLE" только в случае необходимости
-- если ни одно из значений алгоритма не указано, по-умолчанию используется "UNDEFINED"

CREATE algorithm = temptable VIEW cat2 AS SELECT * FROM catalogs;
-- в созданном представлении мы требуем от MySQL при каждом обращении к представлению создавать временную таблицу

-- Следует отметить, что представления способны скрывать ряд столбцов за счёт того, что в SELECT-запросе могут
-- извлекаться не все столбцы таблицы. Такие представления называются "вертикальными"
DESCRIBE products;
CREATE OR REPLACE VIEW prod AS
SELECT id, name, price, catalog_id
FROM products
ORDER BY catalog_id, name;

SELECT *
FROM prod;

SELECT *
FROM prod
ORDER BY name DESC;

-- На ряду с "вертикальными" представлениями используются "горизонтальные"

/*-------Создадим представление, которое извлекает из таблицы "products" только процессоры-------*/
CREATE OR REPLACE VIEW processors AS
SELECT id, name, price, catalog_id
FROM products
WHERE catalog_id = 1;

SELECT *
FROM processors;

-- В реальной практике могут встречаться смешанные представления, кот. ограничивают таблицу и по горизонтали и по
-- вертикали

-- Для того чтобы в представления можно было вставлять записи при помощи команды "INSERT" и обновлять существующие
-- записи при помощи команды "UPDATE", необходимо при создании представления использовать конструкцию "WITH CHECK
-- OPTION"
-- 
-- CREATE VIEW v1 AS
-- SELECT *
-- FROM tbl1
-- WHERE value < 'fst5'
-- WITH CHECK OPTION;
-- 
-- -- давайте попробуем вставить запись
-- INSERT INTO v1
-- VALUES ('fst4');
-- 
-- -- однако при попытке вставить значение 'fst5' срабатывает ограничение "WHERE"-условия
-- INSERT INTO v1
-- VALUES ('fst5');
-- 
-- -- Отредактировать представление можно при помощи команды "ALTER"
-- ALTER VIEW v1 AS
-- SELECT *
-- FROM tbl1
-- WHERE value > 'fst4'
-- WITH CHECK OPTION;
-- 
-- -- либо
-- CREATE OR REPLACE VIEW v1 AS
-- SELECT *
-- FROM tbl1
-- WHERE value > 'fst4'
-- WITH CHECK OPTION;
-- 
-- эти две команды эквивалентны

-- Для удаления представления существует команда "DROP VIEW"
DROP VIEW cat, cat_reverse, namecat, prod, processors;

-- При попытке удаления несуществующего представления возникает ошибка, для избежания этого используется конструкция
-- "IF EXISTS"
DROP VIEW IF EXISTS cat, cat_reverse, namecat, prod, processors;
